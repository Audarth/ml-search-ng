<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.1">
  <meta charset="utf-8">
  <title>Source: ml-search.service.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: ml-search.service.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>(function() {
  &#x27;use strict&#x27;;

  // capture injected services for access throughout this module
  var $q = null,
      $location = null,
      mlRest = null,
      qb = null;

  angular.module(&#x27;ml.search&#x27;)
    .factory(&#x27;MLSearchFactory&#x27;, MLSearchFactory);

  MLSearchFactory.$inject = [&#x27;$q&#x27;, &#x27;$location&#x27;, &#x27;MLRest&#x27;, &#x27;MLQueryBuilder&#x27;];

  /**
   * @class MLSearchFactory
   * @classdesc angular factory for creating instances of {@link MLSearchContext}
   *
   * @param {Object} $q - angular promise service
   * @param {Object} $location - angular location service
   * @param {MLRest} MLRest - low-level ML REST API wrapper (from {@link https://github.com/joemfb/ml-common-ng})
   * @param {MLQueryBuilder} MLQueryBuilder - structured query builder (from {@link https://github.com/joemfb/ml-common-ng})
   */
  // jscs:disable checkParamNames
  function MLSearchFactory($injectQ, $injectLocation, $injectMlRest, $injectQb) {
    $q = $injectQ;
    $location = $injectLocation;
    mlRest = $injectMlRest;
    qb = $injectQb;

    return {
      /**
       * returns a new instance of {@link MLSearchContext}
       * @method MLSearchFactory#newContext
       *
       * @param {Object} options (to override {@link MLSearchContext.defaults})
       * @returns {MLSearchContext}
       */
      newContext: function newContext(options) {
        return new MLSearchContext(options);
      }
    };
  }

  /**
   * @class MLSearchContext
   * @classdesc class for maintaining and manipulating the state of a search context
   *
   * @param {Object} options - provided object properties will override {@link MLSearchContext.defaults}
   *
   * @prop {MLQueryBuilder} qb - query builder service from &#x60;ml.common&#x60;
   * @prop {Object} results - search results
   * @prop {Object} storedOptions - cache stored search options by name
   * @prop {Object} activeFacets - active facet selections
   * @prop {Object} namespaces - namespace prefix-to-URI mappings
   * @prop {Object[]} boostQueries - boosting queries to be added to the current query
   * @prop {Object[]} additionalQueries - additional queries to be added to the current query
   * @prop {String} searchTransform - search results transformation name
   * @prop {String} qtext - current search phrase
   * @prop {Number} start - current pagination offset
   * @prop {Object} options - configuration options
   */
  function MLSearchContext(options) {
    this.qb = qb;
    this.results = {};
    this.storedOptions = {};
    this.activeFacets = {};
    this.namespaces = {};
    this.boostQueries = [];
    this.additionalQueries = [];
    this.searchTransform = null;
    this.qtext = null;
    this.start = 1;

    // TODO: validate options
    this.options = _.merge( _.cloneDeep(this.defaults), options );
  }

  angular.extend(MLSearchContext.prototype, {

    /************************************************************/
    /**************** MLSearchContext properties ****************/
    /************************************************************/

    /**
     * pass an object to &#x60;new MLSearchContext()&#x60; or {@link MLSearchFactory#newContext}
     * with any of these properties to override their values
     *
     * @type object
     * @memberof MLSearchContext
     * @static
     *
     * @prop {String} defaults.queryOptions - stored search options name (&#x60;&#x27;all&#x27;&#x60;)
     * @prop {String} defaults.suggestOptions - stored search options name for suggestions (&#x60;same as queryOptions&#x60;)
     * @prop {Number} defaults.pageLength - results page length (&#x60;10&#x60;)
     * @prop {String} defaults.snippet - results transform operator state-name (&#x60;&#x27;compact&#x27;&#x60;)
     * @prop {String} defaults.sort - sort operator state-name (&#x60;null&#x60;)
     * @prop {String} defaults.facetMode - determines if facets are combined in an &#x60;and-query&#x60; or an &#x60;or-query&#x60; (&#x60;and&#x60;)
     * @prop {Boolean} defaults.includeProperties - include document properties in queries (&#x60;false&#x60;)
     * @prop {Boolean} defaults.includeAggregates - automatically get aggregates for facets (&#x60;false&#x60;)
     * @prop {Object} defaults.params - URL params settings
     * @prop {String} defaults.params.separator - constraint-name and value separator (&#x60;&#x27;:&#x27;&#x60;)
     * @prop {String} defaults.params.qtext - qtext parameter name (&#x60;&#x27;qtext&#x27;&#x60;)
     * @prop {String} defaults.params.facets - facets parameter name (&#x60;&#x27;f&#x27;&#x60;)
     * @prop {String} defaults.params.sort - sort parameter name (&#x60;&#x27;s&#x27;&#x60;)
     * @prop {String} defaults.params.page - page parameter name (&#x60;&#x27;p&#x27;&#x60;)
     * @prop {String} defaults.params.prefix - optional string prefix for each parameter name (&#x60;null&#x60;)
     * @prop {String} defaults.params.prefixSeparator - separator for prefix and parameter name. (&#x60;null&#x60;) &amp;lt;br&gt;if &#x60;null&#x60;, &#x60;options.params.separator&#x60; is used as the prefix separator
     */
    defaults: {
      queryOptions: &#x27;all&#x27;,
      suggestOptions: null,
      pageLength: 10,
      snippet: &#x27;compact&#x27;,
      sort: null,
      facetMode: &#x27;and&#x27;,
      includeProperties: false,
      includeAggregates: false,
      params: {
        separator: &#x27;:&#x27;,
        qtext: &#x27;q&#x27;,
        facets: &#x27;f&#x27;,
        negatedFacets: &#x27;n&#x27;,
        sort: &#x27;s&#x27;,
        page: &#x27;p&#x27;,
        prefix: null,
        prefixSeparator: null
        //TODO: queryOptions?
      }
    },

    /************************************************************/
    /******** MLSearchContext instance getters/setters **********/
    /************************************************************/

    /**
     * Gets the object repesenting active facet selections
     * @method MLSearchContext#getActiveFacets
     *
     * @return {Object} &#x60;this.activeFacets&#x60;
     */
    getActiveFacets: function getActiveFacets() {
      return this.activeFacets;
    },

    /**
     * Get namspace prefix by URI
     * @method MLSearchContext#getNamespacePrefix
     *
     * @param {String} uri
     * @return {String} prefix
     */
    getNamespacePrefix: function getNamespacePrefix(uri) {
      return this.namespaces[ uri ];
    },

    /**
     * Get namspace URI by prefix
     * @method MLSearchContext#getNamespaceUri
     *
     * @param {String} prefix
     * @return {String} uri
     */
    getNamespaceUri: function getNamespacePrefix(prefix) {
      return _.chain(this.namespaces)
        .map(function(nsPrefix, uri) {
          if (prefix === nsPrefix) {
            return uri;
          }
        })
        .compact()
        .first()
        .value();
    },

    /**
     * Gets namespace prefix-to-URI mappings
     * @method MLSearchContext#getNamespaces
     *
     * @return {Object[]} namespace prefix-to-URI mapping objects
     */
    getNamespaces: function getNamespaces() {
      var namespaces = [];
      _.forIn(this.namespaces, function(prefix, uri) {
        namespaces.push({ prefix: prefix, uri: uri });
      });
      return namespaces;
    },

    /**
     * Sets namespace prefix-&gt;URI mappings
     * @method MLSearchContext#setNamespaces
     *
     * @param {Object[]} namespaces - objects with &#x60;uri&#x60; and &#x60;prefix&#x60; properties
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setNamespaces: function setNamespaces(namespaces) {
      // TODO: this.clearNamespaces() first?
      _.each(namespaces, this.addNamespace, this);
      return this;
    },

    /**
     * Adds a namespace prefix-&gt;URI mapping
     * @method MLSearchContext#addNamespace
     *
     * @param {Object} namespace object with &#x60;uri&#x60; and &#x60;prefix&#x60; properties
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    addNamespace: function addNamespace(namespace) {
      this.namespaces[ namespace.uri ] = namespace.prefix;
      return this;
    },

    /**
     * Clears namespace prefix-&gt;URI mappings
     * @method MLSearchContext#clearNamespaces
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearNamespaces: function clearNamespaces() {
      this.namespaces = {};
      return this;
    },

    /**
     * Gets the boost queries
     * @method MLSearchContext#getBoostQueries
     *
     * @return {Array} &#x60;this.boostQueries&#x60;
     */
    getBoostQueries: function getBoostQueries() {
      return this.boostQueries;
    },

    /**
     * Adds a boost query to &#x60;this.boostQueries&#x60;
     * @method MLSearchContext#addBoostQuery
     *
     * @param {Object} query - boost query
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    addBoostQuery: function addBoostQuery(query) {
      this.boostQueries.push(query);
      return this;
    },

    /**
     * Clears the boost queries
     * @method MLSearchContext#clearBoostQueries
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearBoostQueries: function clearBoostQueries() {
      this.boostQueries = [];
      return this;
    },

    /**
     * Gets the additional queries
     * @method MLSearchContext#getAdditionalQueries
     *
     * @return {Object} &#x60;this.additionalQueries&#x60;
     */
    getAdditionalQueries: function getAdditionalQueries() {
      return this.additionalQueries;
    },

    /**
     * Adds an additional query to &#x60;this.additionalQueries&#x60;
     * @method MLSearchContext#addAdditionalQuery
     *
     * @param {Object} query - additional query
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    addAdditionalQuery: function addAdditionalQuery(query) {
      this.additionalQueries.push(query);
      return this;
    },

    /**
     * Clears the additional queries
     * @method MLSearchContext#clearAdditionalQueries
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearAdditionalQueries: function clearAdditionalQueries() {
      this.additionalQueries = [];
      return this;
    },

    /**
     * Gets the search transform name
     * @method MLSearchContext#getTransform
     *
     * @return {String} transform name
     */
    getTransform: function getTransform(transform) {
      return this.searchTransform;
    },

    /**
     * Sets the search transform name
     * @method MLSearchContext#setTransform
     *
     * @param {String} transform - transform name
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setTransform: function setTransform(transform) {
      this.searchTransform = transform;
      return this;
    },

    /**
     * Gets the current search phrase
     * @method MLSearchContext#getText
     *
     * @return {String} search phrase
     */
    getText: function getText() {
      return this.qtext;
    },

    /**
     * Sets the current search phrase
     * @method MLSearchContext#setText
     *
     * @param {String} text - search phrase
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setText: function setText(text) {
      if (text !== &#x27;&#x27;) {
        this.qtext = text;
      } else {
        this.qtext = null;
      }
      return this;
    },

    /**
     * Gets the current search page
     * @method MLSearchContext#getPage
     *
     * @return {Number} search page
     */
    getPage: function getPage() {
      //TODO: $window.Math
      var page = Math.floor(this.start / this.options.pageLength) + 1;
      return page;
    },

    /**
     * Sets the search results page
     * @method MLSearchContext#setPage
     *
     * @param {Number} page - the desired search results page
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setPage: function setPage(page) {
      page = parseInt(page) || 1;
      this.start = 1 + (page - 1) * this.options.pageLength;
      return this;
    },

    /************************************************************/
    /********* MLSearchContext options getters/setters **********/
    /************************************************************/

    /**
     * Gets the current queryOptions (name of stored params)
     * @method MLSearchContext#getQueryOptions
     *
     * @return {String} queryOptions
     */
    getQueryOptions: function getQueryOptions() {
      return this.options.queryOptions;
    },

    /**
     * Gets the current suggestOptions (name of stored params for suggestions)
     * @method MLSearchContext#getSuggestOptions
     *
     * @return {String} suggestOptions
     */
    getSuggestOptions: function getSuggestOptions() {
      return this.options.suggestOptions;
    },

    /**
     * Gets the current page length
     * @method MLSearchContext#getPageLength
     *
     * @return {Number} page length
     */
    getPageLength: function getPageLength() {
      return this.options.pageLength;
    },

    /**
     * Sets the current page length
     * @method MLSearchContext#setPageLength
     *
     * @param {Number} pageLength - page length
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setPageLength: function setPageLength(pageLength) {
      this.options.pageLength = pageLength;
      return this;
    },

    /**
     * Gets the current results transform operator state name
     * @method MLSearchContext#getSnippet
     *
     * @return {String} operator state name
     */
    getSnippet: function getSnippet() {
      return this.options.snippet;
    },

    /**
     * Sets the current results transform operator state name
     * @method MLSearchContext#setSnippet
     *
     * @param {String} snippet - operator state name
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setSnippet: function setSnippet(snippet) {
      this.options.snippet = snippet;
      return this;
    },

    /**
     * Clears the results transform operator (resets it to its default value)
     * @method MLSearchContext#clearSnippet
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearSnippet: function clearSnippet() {
      this.options.snippet = this.defaults.snippet;
      return this;
    },

    /**
     * Gets the current sort operator state name
     * @method MLSearchContext#getSort
     *
     * @return {String} sort operator state name
     */
    getSort: function getSort() {
      return this.options.sort;
    },

    /**
     * Sets the current sort operator state name
     * @method MLSearchContext#setSort
     *
     * @param {String} sort - sort operator state name
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setSort: function setSort(sort) {
      this.options.sort = sort;
      return this;
    },

    /**
     * Clears the sort operator state name (resets it to its default value)
     * @method MLSearchContext#clearSort
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearSort: function clearSort() {
      this.options.sort = this.defaults.sort;
      return this;
    },

    /**
     * Gets the current facet mode (determines if facet values are combined in an &#x60;and-query&#x60; or an &#x60;or-query&#x60;)
     * @method MLSearchContext#getFacetMode
     *
     * @return {String} facet mode
     */
    getFacetMode: function getFacetMode() {
      return this.options.facetMode;
    },

    /**
     * Sets the current facet mode (&#x60;and&#x60;|&#x60;or&#x60;). (determines if facet values are combined in an &#x60;and-query&#x60; or an &#x60;or-query&#x60;)
     * @method MLSearchContext#setFacetMode
     *
     * @param {String} facetMode - &#x27;and&#x27; or &#x27;or&#x27;
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    setFacetMode: function setFacetMode(facetMode) {
      //TODO: validate facetMode
      this.options.facetMode = facetMode;
      return this;
    },

    /**
     * Gets the current URL params config object
     * @method MLSearchContext#getParamsConfig
     *
     * @return {Object} params config
     */
    getParamsConfig: function getParamsConfig() {
      return this.options.params;
    },

    /**
     * Gets the key of the enabled URL params
     * @method MLSearchContext#getParamsKeys
     *
     * @return {Array&amp;lt;String&gt;} URL params keys
     */
    getParamsKeys: function getParamsKeys() {
      var prefix = this.getParamsPrefix();
      return _.chain( this.options.params )
        .omit([&#x27;separator&#x27;, &#x27;prefix&#x27;, &#x27;prefixSeparator&#x27;])
        .map(function(value) {
          return prefix + value;
        })
        .compact()
        .value();
    },

    /**
     * Gets the URL params prefix
     * @method MLSearchContext#getParamsPrefix
     *
     * @return {String} the defined params prefix + separator
     */
    getParamsPrefix: function getParamsPrefix() {
      var prefix = &#x27;&#x27;;

      if ( this.options.params.prefix !== null ) {
        prefix = this.options.params.prefix + (
                   this.options.params.prefixSeparator ||
                   this.options.params.separator
                 );
      }

      return prefix;
    },

    //TODO: setParamsConfig ?

    /************************************************************/
    /************** MLSearchContext query builders **************/
    /************************************************************/

    /**
     * Constructs a structured query from the current state
     * @method MLSearchContext#getQuery
     *
     * @return {Object} a structured query object
     */
    getQuery: function getQuery() {
      var query = qb.and();

      if ( _.keys(this.activeFacets).length ) {
        query = this.getFacetQuery();
      }

      if ( this.qtext ) {
        query = qb.and( query, qb.text( this.qtext ) );
      }

      if ( this.boostQueries.length ) {
        query = qb.boost(query, this.boostQueries);
      }

      if ( this.additionalQueries.length ) {
        query = qb.and(query, this.additionalQueries);
      }

      if ( this.options.includeProperties ) {
        query = qb.or(query, qb.properties(query));
      }

      query = qb.query(query);

      if ( this.options.sort ) {
        // TODO: this assumes that the sort operator is called &quot;sort&quot;, but
        // that isn&#x27;t necessarily true. Properly done, we&#x27;d get the options
        // from the server and find the operator that contains sort-order
        // elements
        query.query.queries.push( qb.operator(&#x27;sort&#x27;, this.options.sort) );
      }

      if ( this.options.snippet ) {
        // same problem as &#x60;sort&#x60;
        query.query.queries.push( qb.operator(&#x27;results&#x27;, this.options.snippet) );
      }

      return query;
    },

    /**
     * constructs a structured query from the current active facets
     * @method MLSearchContext#getFacetQuery
     *
     * @return {Object} a structured query object
     */
    getFacetQuery: function getFacetQuery() {
      var self = this,
          queries = [],
          query = {},
          constraintFn;

      _.forIn( self.activeFacets, function(facet, facetName) {
        if ( facet.values.length ) {
          constraintFn = function(facetValueObject) {
            var constraintQuery = qb.constraint( facet.type )( facetName, facetValueObject.value );
            if (facetValueObject.negated === true) {
              constraintQuery = qb.not(constraintQuery);
            }
            return constraintQuery;
          };

          queries = queries.concat( _.map(facet.values, constraintFn) );
        }
      });

      if ( self.options.facetMode === &#x27;or&#x27; ) {
        query = qb.or(queries);
      } else {
        query = qb.and(queries);
      }

      return query;
    },

    /**
     * Construct a combined query from the current state
     * @method MLSearchContext#getCombinedQuery
     *
     * @param {Boolean} [includeOptions] - if &#x60;true&#x60;, get and include the stored search options (defaults to &#x60;false&#x60;)
     *
     * @return {Promise} - a promise resolved with the combined query
     */
    getCombinedQuery: function getCombinedQuery(includeOptions) {
      var d = $q.defer(),
          combined = {
            search: { query: this.getQuery() }
          };

      if ( !includeOptions ) {
        d.resolve(combined);
        return d.promise;
      }

      return this.getStoredOptions()
      .then(function(data) {
        combined.search.options = data.options;
        return combined;
      });
    },

    /************************************************************/
    /************** MLSearchContext facet methods ***************/
    /************************************************************/

    /**
     * Check if the facet/value combination is already selected
     * @method MLSearchContext#isFacetActive
     *
     * @param {String} name - facet name
     * @param {String} value - facet value
     * @return {Boolean} isSelected
     */
    isFacetActive: function isFacetActive(name, value) {
      var active = this.activeFacets[name];
      return !!active &amp;amp;&amp;amp; !!_.find(active.values, { value: value });
    },

    /**
     * Check if the facet/value combination selected &amp;amp; negated
     * @method MLSearchContext#isFacetNegated
     *
     * @param {String} name - facet name
     * @param {String} value - facet value
     * @return {Boolean} isNegated
     */
    isFacetNegated: function isFacetNegated(name, value) {
      var active = this.activeFacets[name];

      if (!active) {
        return false;
      }
      var facet = _.find(active.values, { value: value });

      if (!!facet) {
        return facet.negated;
      } else {
        return false;
      }
    },

    /**
     * Add the facet/value/type combination to the activeFacets list
     * @method MLSearchContext#selectFacet
     *
     * @param {String} name - facet name
     * @param {String} value - facet value
     * @param {String} type - facet type
     * @param {Boolean} isNegated - facet negated (default to false)
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    selectFacet: function selectFacet(name, value, type, isNegated) {
      if (/^&quot;(.*)&quot;$/.test(value)) {
        value = value.replace(/^&quot;(.*)&quot;$/, &#x27;$1&#x27;);
      }
      var active = this.activeFacets[name],
          negated = isNegated || false,
          valueObject = { value: value, negated: negated };

      if (active &amp;amp;&amp;amp; !this.isFacetActive(name, value) ) {
        active.values.push(valueObject);
      } else {
        this.activeFacets[name] = { type: type, values: [valueObject] };
      }

      return this;
    },

    /**
     * Removes the facet/value combination from the activeFacets list
     * @method MLSearchContext#clearFacet
     *
     * @param {String} name - facet name
     * @param {String} value - facet value
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearFacet: function clearFacet(name, value) {
      var active = this.activeFacets[name];

      active.values = _.filter( active.values, function(facetValueObject) {
        return facetValueObject.value !== value;
      });

      if ( !active.values.length ) {
        delete this.activeFacets[name];
      }

      return this;
    },

    /**
     * If facet/value combination is active, remove it from the activeFacets list
     *   otherwise, find it&#x27;s type, and add it.
     * @method MLSearchContext#toggleFacet
     *
     * @param {String} name - facet name
     * @param {String} value - facet value
     * @param {Boolean} isNegated - facet negated
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    toggleFacet: function toggleFacet(name, value, isNegated) {
      var config;

      if ( this.isFacetActive(name, value) ) {
        this.clearFacet(name, value);
      } else {
        config = this.getFacetConfig(name);

        this.selectFacet(name, value, config.type, isNegated);
      }

      return this;
    },

    /**
     * Clears the activeFacets list
     * @method MLSearchContext#clearAllFacets
     *
     * @return {MLSearchContext} &#x60;this&#x60;
     */
    clearAllFacets: function clearAllFacets() {
      this.activeFacets = {};
      return this;
    },

    /**
     * Retrieve additional values for the provided &#x60;facet&#x60; object,
     * appending them to the facet&#x27;s &#x60;facetValues&#x60; array. Sets &#x60;facet.displayingAll = true&#x60;
     * once no more values are available.
     *
     * @method MLSearchContext#showMoreFacets
     *
     * @param {Object} facet - a facet object returned from {@link MLSearchContext#search}
     * @param {String} facetName - facet name
     * @param {Number} [step] - the number of additional facet values to retrieve (defaults to &#x60;5&#x60;)
     *
     * @return {Promise} a promise resolved once additional facets have been retrieved
     */
    showMoreFacets: function showMoreFacets(facet, facetName, step) {
      step = step || 5;

      var start = facet.facetValues.length + 1,
          limit = start + step - 1;

      return this.valuesFromConstraint(facetName, { start: start, limit: limit })
      .then(function(resp) {
        var newFacets = resp &amp;amp;&amp;amp; resp.data &amp;amp;&amp;amp; resp.data[&#x27;values-response&#x27;] &amp;amp;&amp;amp;
                        resp.data[&#x27;values-response&#x27;][&#x27;distinct-value&#x27;];

        facet.displayingAll = (!newFacets || newFacets.length &amp;lt; (limit - start));

        _.each(newFacets, function(newFacetValue) {
          facet.facetValues.push({
            name: newFacetValue._value,
            value: newFacetValue._value,
            count: newFacetValue.frequency
          });
        });

        return facet;
      });
    },

    /************************************************************/
    /************ MLSearchContext URL params methods ************/
    /************************************************************/

    /**
     * Construct a URL query params object from the current state
     * @method MLSearchContext#getParams
     *
     * @return {Object} params - a URL query params object
     */
    getParams: function getParams() {
      var page = this.getPage(),
          facetParams = this.getFacetParams(),
          facets = facetParams.facets,
          negated = facetParams.negatedFacets,
          params = {},
          prefix = this.getParamsPrefix();

      if ( facets.length &amp;amp;&amp;amp; this.options.params.facets !== null ) {
        params[ prefix + this.options.params.facets ] = facets;
      }

      if ( negated.length &amp;amp;&amp;amp; this.options.params.negatedFacets !== null ) {
        params[ prefix + this.options.params.negatedFacets ] = negated;
      }

      if ( page &gt; 1 &amp;amp;&amp;amp; this.options.params.page !== null ) {
        params[ prefix + this.options.params.page ] = page;
      }

      if ( this.qtext &amp;amp;&amp;amp; this.options.params.qtext !== null ) {
        params[ prefix + this.options.params.qtext ] = this.qtext;
      }

      if ( this.options.sort &amp;amp;&amp;amp; this.options.params.sort !== null ) {
        params[ prefix + this.options.params.sort ] = this.options.sort;
      }

      return params;
    },

    /**
     * Construct an array of facet selections (&#x60;name&#x60; &#x60;separator&#x60; &#x60;value&#x60;) from &#x60;this.activeFacets&#x60; for use in a URL query params object
     * @method MLSearchContext#getFacetParams
     *
     * @return {Array&amp;lt;String&gt;} an array of facet URL query param values
     */
    getFacetParams: function getFacetParams() {
      var self = this,
          facetQuery = self.getFacetQuery(),
          queries = [],
          facets = { facets: [], negatedFacets: [] };

      queries = ( facetQuery[&#x27;or-query&#x27;] || facetQuery[&#x27;and-query&#x27;] ).queries;
      _.each(queries, function(query) {
        var queryType = _.keys(query)[0],
            constraint,
            name,
            arrayToPushTo;

        if (queryType === &#x27;not-query&#x27;) {
          constraint = query[queryType][_.keys(query[queryType])[0]];
          arrayToPushTo = facets.negatedFacets;
        } else {
          constraint = query[ queryType ];
          arrayToPushTo = facets.facets;
        }

        name = constraint[&#x27;constraint-name&#x27;];

        _.each( constraint.value || constraint.uri, function(value) {
          // quote values with spaces
          if (/\s+/.test(value) &amp;amp;&amp;amp; !/^&quot;(.*)&quot;$/.test(value)) {
            value = &#x27;&quot;&#x27; + value + &#x27;&quot;&#x27;;
          }
          arrayToPushTo.push( name + self.options.params.separator + value );
        });
      });

      return facets;
    },

    /**
     * Gets the current search related URL params (excluding any params not controlled by {@link MLSearchContext})
     * @method MLSearchContext#getCurrentParams
     *
     * @param {Object} [params] - URL params (defaults to &#x60;$location.search()&#x60;)
     * @return {Object} search-related URL params
     */
    getCurrentParams: function getCurrentParams(params) {
      var prefix = this.getParamsPrefix();

      params = _.pick(
        params || $location.search(),
        this.getParamsKeys()
      );

      _.chain(this.options.params)
      .pick([&#x27;facets&#x27;, &#x27;negatedFacets&#x27;])
      .values()
      .each(function(key) {
        var name = prefix + key;

        if ( params[ name ] ) {
          params[ name ] = asArray(params[ name ]);
        }
      })
      .value();

      return params;
    },

    /**
     * Updates the current state based on the URL query params
     * @method MLSearchContext#fromParams
     *
     * @param {Object} [params] - a URL query params object (defaults to &#x60;$location.search()&#x60;)
     * @return {Promise} a promise resolved once the params have been applied
     */
    fromParams: function fromParams(params) {
      var self = this,
          d = $q.defer(),
          paramsConf = this.options.params;

      params = this.getCurrentParams( params );

      this.fromParam( paramsConf.qtext, params,
        this.setText.bind(this),
        this.setText.bind(this, null)
      );

      this.fromParam( paramsConf.page, params,
        this.setPage.bind(this),
        this.setPage.bind(this, 1)
      );

      this.fromParam( paramsConf.sort, params,
        this.setSort.bind(this)
      );

      self.clearAllFacets();

      //this parses the facets then the negated ones since they both depend on the same MarkLogic facet data
      this.fromParam( paramsConf.facets, params,
        function(val) {

          // ensure that facet type information is available
          if ( self.results.facets ) {
            self.fromFacetParam(val);

            self.fromParam( paramsConf.negatedFacets, params,
              function(val) {
                self.fromFacetParam(val, undefined, true);
                d.resolve();
              },
              d.resolve
            );
          } else {
            self.getStoredOptions().then(function(options) {
              self.fromFacetParam(val, options);
              self.fromParam( paramsConf.negatedFacets, params,
                function(val) {
                  self.fromFacetParam(val, options, true);
                  d.resolve();
                },
                d.resolve
              );
            });
          }
        },
        d.resolve
      );

      return d.promise;
    },

    /**
     * Get the value for the given type of URL param, handling prefixes
     * @method MLSearchContext#fromParam
     * @private
     *
     * @param {String} name - URL param name
     * @param {Object} params - URL params
     * @param {Function} callback - callback invoked with the value of the URL param
     * @param {Function} defaultCallback - callback invoked if params are un-prefix&#x27;d and no value is provided
     */
    fromParam: function fromParam(name, params, callback, defaultCallback) {
      var prefixedName = this.getParamsPrefix() + name,
          value = params[ prefixedName ];

      if ( name === null ) {
        return;
      }

      if ( !value ) {
        if ( defaultCallback ) {
          defaultCallback.call(this);
        }
        return;
      }

      if ( _.isString(value) ) {
        value = decodeParam(value);
      }

      callback.call( this, value );
    },

    /**
     * Updates the current active facets based on the provided facet URL query params
     * @method MLSearchContext#fromFacetParam
     * @private
     *
     * @param {Array|String} param - facet URL query params
     * @param {Object} [storedOptions] - a searchOptions object
     * @param {Boolean} isNegated - whether the facet should be negated (defaults to false)
     */
    fromFacetParam: function fromFacetParam(param, storedOptions, isNegated) {
      var self = this,
          values = _.map( asArray(param), decodeParam ),
          negated = isNegated || false;

      _.each(values, function(value) {
        var tokens = value.split( self.options.params.separator ),
            facetName = tokens[0],
            facetValue = tokens[1],
            facetInfo = self.getFacetConfig( facetName, storedOptions ) || {};

        if ( !facetInfo.type ) {
          console.error(&#x27;don\&#x27;t have facets or options for \&#x27;&#x27; + facetName +
                        &#x27;\&#x27;, falling back to un-typed range queries&#x27;);
        }

        self.selectFacet( facetName, facetValue, facetInfo.type, negated );
      });
    },

    /**
     * Gets the &quot;facet config&quot;: either a facet response or a constraint definition object
     *
     * (this function is called in a tight loop, so loading the options async won&#x27;t work)
     *
     * @method MLSearchContext#getFacetConfig
     * @private
     *
     * @param {String} name - facet name
     * @param {Object} [storedOptions] - a searchOptions object
     * @return {Object} facet config
     */
    getFacetConfig: function getFacetConfig(name, storedOptions) {
      var config = null;

      if ( !!storedOptions ) {
        config = _.chain( storedOptions.options.constraint )
          .where({ name: name })
          .first()
          .clone()
          .value();

        config.type = config.collection ? &#x27;collection&#x27; :
                      config.custom ? &#x27;custom&#x27; :
                      config.range.type;
      } else if ( !!this.results.facets &amp;amp;&amp;amp; this.results.facets[ name ] ) {
        config = this.results.facets[ name ];
      }

      return config;
    },

    /**
     * Examines the current state, and determines if a new search is needed.
     *   (intended to be triggered on &#x60;$locationChangeSuccess&#x60;)
     * @method MLSearchContext#locationChange
     *
     * @param {String} newUrl - the target URL of a location change
     * @param {String} oldUrl - the original URL of a location change
     * @param {Object} params - the search params of the target URL
     *
     * @return {Promise} a promise resolved after calling {@link MLSearchContext#fromParams} (if a new search is needed)
     */
    locationChange: function locationChange(newUrl, oldUrl, params) {
      var d = $q.defer();

      params = this.getCurrentParams( params );

      // still on the search page, but there&#x27;s a new query
      var shouldUpdate = pathsEqual(newUrl, oldUrl) &amp;amp;&amp;amp;
                         !_.isEqual( this.getParams(), params );

      if ( shouldUpdate ) {
        return this.fromParams(params);
      }

      d.reject();
      return d.promise;
    },

    /************************************************************/
    /********** MLSearchContext data retrieval methods **********/
    /************************************************************/

    /**
     * Retrieves stored search options, caching the result in &#x60;this.storedOptions&#x60;
     * @method MLSearchContext#getStoredOptions
     *
     * @param {String} [name] - the name of the options to retrieve (defaults to &#x60;this.getQueryOptions()&#x60;)
     * @return {Promise} a promise resolved with the stored options
     */
    getStoredOptions: function getStoredOptions(name) {
      var self = this,
          d = $q.defer();

      name = name || self.getQueryOptions();

      if ( self.storedOptions[name] ) {
        d.resolve( self.storedOptions[name] );
        return d.promise;
      }

      return mlRest.queryConfig(name)
      .then(function(response) {
        //TODO: transform?
        self.storedOptions[name] = response.data;
        return self.storedOptions[name];
      });
    },

    /**
     * Retrieves stored search options, caching the result in &#x60;this.storedOptions&#x60;
     * @method MLSearchContext#getAllStoredOptions
     *
     * @param {String[]} names - the names of the options to retrieve
     * @return {Promise} a promise resolved with an object containing the requested search options, keyed by name
     */
    getAllStoredOptions: function getAllStoredOptions(names) {
      var self = this,
          result = {};

      // cache any options not already loaded
      return $q.all( _.map(names, self.getStoredOptions.bind(self)) ).then(function() {
        // return only the names requested
        _.each(names, function(name) {
          result[name] = self.storedOptions[name];
        });
        return result;
      });
    },

    /**
     * Retrieves search phrase suggestions based on the current state
     * @method MLSearchContext#suggest
     *
     * @param {String} qtext - the partial-phrase to match
     * @param {String|Object} [options] - string options name (to override suggestOptions), or object for adhoc combined query options
     * @return {Promise} a promise resolved with search phrase suggestions
     */
    suggest: function suggest(qtext, options) {
      var params = {
        &#x27;partial-q&#x27;: qtext,
        format: &#x27;json&#x27;,
        options: (_.isString(options) &amp;amp;&amp;amp; options) || this.getSuggestOptions() || this.getQueryOptions()
      };

      return this.getCombinedQuery(false)
      .then(function(combined) {
        if ( _.isObject(options) ) {
          combined.search.options = options;
        }
        return mlRest.suggest(params, combined);
      })
      .then(function(response) {
        return response.data;
      });
    },

    /**
     * Retrieves values from a lexicon (based on a constraint definition)
     * @method MLSearchContext#valuesFromConstraint
     *
     * @param {String} name - the name of a search &#x60;constraint&#x60; definition
     * @param {Object} [params] - URL params
     * @return {Promise} a promise resolved with values
     */
    valuesFromConstraint: function values(name, params) {
      var self = this;

      return this.getStoredOptions()
      .then(function(storedOptions) {
        var constraint = getConstraint(storedOptions, name);

        if ( !constraint ) {
          return $q.reject(new Error(&#x27;No constraint exists matching &#x27; + name));
        }

        var newOptions = valueOptionsFromConstraint(constraint);

        return self.values(name, params, newOptions);
      });
    },

    /**
     * Retrieves values or tuples from 1-or-more lexicons
     * @method MLSearchContext#values
     *
     * @param {String} name - the name of a &#x60;value-option&#x60; definition
     * @param {Object} [params] - URL params
     * @param {Object} [options] - search options, used in a combined query
     * @return {Promise} a promise resolved with values
     */
    values: function values(name, params, options) {
      var self = this;

      if ( !options &amp;amp;&amp;amp; params &amp;amp;&amp;amp; params.options &amp;amp;&amp;amp; !(params.start || params.limit) ) {
        options = params;
        params = null;
      }

      params = params || {};
      params.start = params.start !== undefined ? params.start : 1;
      params.limit = params.limit !== undefined ? params.limit : 20;

      if ( !options ) {
        params.options = self.getQueryOptions();
      }

      return self.getCombinedQuery(false)
      .then(function(combined) {
        combined.search.options = options;
        return mlRest.values(name, params, combined);
      });
    },

    /**
     * Retrieves search results based on the current state
     *
     * If an object is passed as the &#x60;adhoc&#x60; parameter, the search will be run as a &#x60;POST&#x60;
     * with a combined query, and the results will not be saved to &#x60;MLSearchContext.results&#x60;.
     * If &#x60;adhoc&#x60; is a combined query, or a search options object, the &#x60;options&#x60; URL parameter
     * will not be included (ignoring stored search options).
     *
     * @method MLSearchContext#search
     *
     * @param {Object} [adhoc] - structured query || combined query || partial search options object
     * @return {Promise} a promise resolved with search results
     */
    search: function search(adhoc) {
      var self = this,
          query = this.getQuery(),
          combined = null,
          includeOptionsParam = true,
          params = {
            start: this.start,
            pageLength: this.options.pageLength,
            transform: this.searchTransform
          };

      if ( adhoc ) {
        combined = {};

        if ( adhoc.search ) {
          includeOptionsParam = false;
          combined.search = adhoc.search;
        } else {
          combined = { search: {} };

          if ( adhoc.options ) {
            includeOptionsParam = false;
            combined.search.options = adhoc.options;
            combined.search.query = query.query;
          } else if ( adhoc.query ) {
            combined.search.query = adhoc.query;
          } else {
            combined.search.options = adhoc;
            combined.search.query = query.query;
          }
        }
      } else {
        params.structuredQuery = query;
      }

      if ( includeOptionsParam ) {
        params.options = this.getQueryOptions();
      }

      return mlRest.search(params, combined)
      .then(function(response) {
        var results = response.data;

        // the results of adhoc queries aren&#x27;t preserved
        if ( !combined ) {
          self.results = results;
        }

        self.transformMetadata(results.results);
        self.annotateActiveFacets(results.facets);

        if (self.options.includeAggregates) {
          // TODO: find some way to conditionally chain this, so that errors are propagated
          self.getAggregates(results.facets);
        }

        return results;
      });
    },

    /**
     * Annotates facets (from a search response object) with the selections from &#x60;this.activeFacets&#x60;
     * @method MLSearchContext#annotateActiveFacets
     *
     * @param {Object} facets - facets object from a search response
     */
    annotateActiveFacets: function annotateActiveFacets(facets) {
      var self = this;

      _.forIn( facets, function(facet, name) {
        var selected = self.activeFacets[name];

        if ( selected ) {
          _.chain(facet.facetValues)
            .filter(function(value) {
              return self.isFacetActive(name, value.name);
            })
            .each(function(value) {
              facet.selected = value.selected = true;
              value.negated = self.isFacetNegated(name, value.name);
            })
            .value(); // thwart lazy evaluation
        }
      });
    },

    /**
     * Gets aggregates for facets (from a search response object) based on facet type
     * @method MLSearchContext#getAggregates
     *
     * @param {Object} facets - facets object from a search response
     * @return {Promise} a promise resolved once facet aggregates have been retrieved
     */
    getAggregates: function getAggregates(facets) {
      var self = this;

      return self.getStoredOptions()
      .then(function(storedOptions) {
        var promises = [];

        try {
          _.forIn( facets, function(facet, facetName) {
            var facetType = facet.type,
                constraint = getConstraint(storedOptions, facetName);

            if ( !constraint ) {
              throw new Error(&#x27;No constraint exists matching &#x27; + facetName);
            }

            var newOptions = valueOptionsFromConstraint(constraint);

            // TODO: update facetType from constraint ?
            // TODO: make the choice of aggregates configurable

            // these work for all index types
            newOptions.values.aggregate = [
              { apply: &#x27;count&#x27; },
              { apply: &#x27;min&#x27; },
              { apply: &#x27;max&#x27; }
            ];

            // TODO: move the scalar-type -&gt; aggregate mappings to MLRest (see https://gist.github.com/joemfb/b682504c7c19cd6fae11)

            var numberTypes = [
              &#x27;xs:int&#x27;,
              &#x27;xs:unsignedInt&#x27;,
              &#x27;xs:long&#x27;,
              &#x27;xs:unsignedLong&#x27;,
              &#x27;xs:float&#x27;,
              &#x27;xs:double&#x27;,
              &#x27;xs:decimal&#x27;
            ];

            if ( _.contains(numberTypes, facetType) ) {

              newOptions.values.aggregate = newOptions.values.aggregate.concat([
                { apply: &#x27;sum&#x27; },
                { apply: &#x27;avg&#x27; },
                // TODO: allow enabling these from config?
                // { apply: &#x27;median&#x27; },
                // { apply: &#x27;stddev&#x27; },
                // { apply: &#x27;stddev-population&#x27; },
                // { apply: &#x27;variance&#x27; },
                // { apply: &#x27;variance-population&#x27; }
              ]);

            }

            promises.push(
              self.values(facetName, { start: 1, limit: 0 }, newOptions)
              .then(function(resp) {
                var aggregates = resp &amp;amp;&amp;amp; resp.data &amp;amp;&amp;amp; resp.data[&#x27;values-response&#x27;] &amp;amp;&amp;amp;
                                 resp.data[&#x27;values-response&#x27;][&#x27;aggregate-result&#x27;];
                _.each( aggregates, function(aggregate) {
                  facet[aggregate.name] = aggregate._value;
                });
              })
            );
          });
        }
        catch (err) {
          return $q.reject(err);
        }

        return $q.all(promises);
      });
    },

    /**
     * Transforms the metadata array in each search response result object to an object, key&#x27;d by &#x60;metadata-type&#x60;
     * @method MLSearchContext#transformMetadata
     *
     * @param {Object} result - results array from a search response (or one result object from the array)
     */
    transformMetadata: function transformMetadata(result) {
      var self = this,
          metadata;

      if ( _.isArray(result) ) {
        _.each(result, this.transformMetadata, self);
        return;
      }

      metadata = result.metadata;
      result.metadata = {};

      _.each(metadata, function(obj) {
        var key = _.without(_.keys(obj), &#x27;metadata-type&#x27;)[0],
            type = obj[ &#x27;metadata-type&#x27; ],
            value = obj[ key ],
            shortKey = null,
            prefix = null,
            ns = null;

        ns = key.replace(/^\{([^}]+)\}.*$/, &#x27;$1&#x27;);
        prefix = self.getNamespacePrefix(ns);

        if ( prefix ) {
          shortKey = key.replace(/\{[^}]+\}/, prefix + &#x27;:&#x27;);
        } else {
          shortKey = key;
        }

        if ( !result.metadata[ shortKey ] ) {
          result.metadata[ shortKey ] = { &#x27;metadata-type&#x27;: type, values: [] };
        }

        result.metadata[ shortKey ].values.push(value);
      });
    },

    /**
     * @method MLSearchContext#getStructuredQuery
     * @deprecated
     *
     * @see MLSearchContext#getQuery
     */
    getStructuredQuery: function getStructuredQuery() {
      return this.getQuery();
    },

    /**
     * @method MLSearchContext#serializeStructuredQuery
     * @deprecated
     *
     * @see MLSearchContext#getParams
     */
    serializeStructuredQuery: function serializeStructuredQuery() {
      return this.getParams();
    }

  });

  function decodeParam(value) {
    return decodeURIComponent(value.replace(/\+/g, &#x27;%20&#x27;));
  }

  function pathsEqual(newUrl, oldUrl) {
    // TODO: use $$urlUtils.urlResolve(), once it&#x27;s available
    // see: https://github.com/angular/angular.js/pull/3302
    // from: https://stackoverflow.com/questions/21516891
    function pathName(href) {
      var x = document.createElement(&#x27;a&#x27;);
      x.href = href;
      return x.pathname;
    }

    return pathName(newUrl) === pathName(oldUrl);
  }

  function getConstraint(storedOptions, name) {
    return storedOptions &amp;amp;&amp;amp; storedOptions.options &amp;amp;&amp;amp; storedOptions.options.constraint &amp;amp;&amp;amp;
           _.where(asArray(storedOptions.options.constraint), { name: name })[0];
  }

  function valueOptionsFromConstraint(constraint) {
    var options = { constraint: asArray(constraint), values: asArray(_.cloneDeep(constraint)) };
    options.values[&#x27;values-option&#x27;] = constraint.range &amp;amp;&amp;amp; constraint.range[&#x27;facet-option&#x27;];
    return options;
  }

  //TODO: move to util module
  function asArray() {
    var args;

    /* istanbul ignore else */
    if ( arguments.length === 1) {
      if (Array.isArray( arguments[0] )) {
        args = arguments[0];
      } else {
        args = [ arguments[0] ];
      }
    } else {
      args = [].slice.call(arguments);
    }

    return args;
  }

})();
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.1 on September 3, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>